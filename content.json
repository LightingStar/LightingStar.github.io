{"pages":[],"posts":[{"title":"juc并发编程01","text":"1 前言今天学习了juc编程，虽然之前没用过这个，但是在高并发场景下肯定用到它，本文算是一个初步认识，对线程以及锁有一个了解，以后有更多认知的话会继续补充。 2 什么是juc juc是java.util.concurrent的缩写，就是java的并发包以及工具类；打开jdk文档，可以大概看下包的情况： 3 线程基础知识回顾 什么是进程和线程 进程：QQ.exe 线程：打字、自动保存….. 一个进程可以包含多个线程，一个进程至少有一个线程！ Java程序至少有两个线程： GC、Main 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 并发、并行 并发：多个线程操作同一个资源，交替执行的过程！ 并行：多个线程同时执行！只有在多核CPU下才能完成！ 所以我们使用多线程或者并发编程的目的：提高效率，让CPU一直工作，达到最高处理性能！ 线程有几种状态 线程有 6 种状态，面向源码学习！ 123456789101112131415161718Thread.Statepublic enum State { // 新建 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待 WAITING, // 延时等待 TIMED_WAITING, // 终止！ TERMINATED;}// java能够创建线程吗？ 不能！调用的是本地方法，线程属于操作系统，java无法调用new Thread().start();private native void start0(); 线程等待，wait/Sleep区别 1、类不同，wait是Object类，sleep是Thread类的 1234//实现线程休眠，之前的做法是：Thread.sleep(20);//juc使用TimeUnit.SECONDS.sleep(20); 2、会不会释放资源！ sleep：抱着锁睡得，不会释放锁！wait 会释放锁！ 3、使用的范围是不同的； wait 和 notify 是一组，一般在线程通信的时候使用！ sleep 就是一个单独的方法，在哪里都可以用！ 4、关于异常; sleep 需要捕获异常！ 4 synchronized 和Lock 传统的Synchronized锁实现方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhangben.demo;/** * @author: 张奔 * @date: 2020/3/3 23:14 * @description: 传统的Synchronized,Synchronized 方法 和 Synchronized 块 * 1、架构：高内聚，低耦合 * 2、套路：线程操作资源类，资源类是单独的 */public class Demo01 { public static void main(String[] args) { // 1、新建资源类 Ticket ticket = new Ticket(); // 2、线程操纵资源类 new Thread(new Runnable() { public void run() { for (int i = 1; i &lt; 40; i++) { ticket.sale(); } } },\"A\").start(); new Thread(new Runnable() { public void run() { for (int i = 1; i &lt; 40; i++) { ticket.sale(); } } },\"B\").start(); new Thread(new Runnable() { public void run() { for (int i = 1; i &lt; 40; i++) { ticket.sale(); } } },\"C\").start(); }}/*单独的资源类，属性和方法！这样才能实现复用！*/class Ticket{ private Integer num = 30; public synchronized void sale(){ if(num&gt;0){ System.out.println(Thread.currentThread().getName()+\"卖出：\"+num--+\"剩余:\"+num); } }} 使用lock： 12345678910111213141516171819202122232425262728293031323334353637383940package com.zhangben.demo;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @description: JUC之后的操作，Lock锁 + lambda表达式！ */public class Demo02 { public static void main(String[] args) { //1、创建资源类 Ticket2 ticket2 = new Ticket2(); //2、线程操作资源类 , 所有的函数式接口都可以用 lambda表达式简化！这里可以简化为1行代码 //lambda表达式 (参数)-&gt;{具体的代码} new Thread(()-&gt;{for (int i = 1; i &lt; 40; i++) ticket2.sale();},\"A\").start(); new Thread(()-&gt;{for (int i = 1; i &lt; 40; i++) ticket2.sale();},\"B\").start(); new Thread(()-&gt;{for (int i = 1; i &lt; 40; i++) ticket2.sale();},\"C\").start(); }}class Ticket2{ // 使用Lock，它是一个对象 // ReentrantLock 可重入锁：回家：大门 (卧室门，厕所门...),后面的都可以获得 // ReentrantLock 默认是非公平锁！可以加参数true变成公平锁 // 非公平锁: 不公平 （插队，后面的线程可以插队） // 公平锁: 公平（只能排队，后面的线程无法插队） private Lock lock = new ReentrantLock(); private int num = 30; public void sale(){ lock.lock();//加锁 try {//业务代码 if(num&gt;0){ System.out.println(Thread.currentThread().getName()+\"卖出：\"+num--+\"剩余:\"+num); } } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock();//释放锁 } }} 区别 1、Synchronized 是一个关键字、Lock 是一个对象 2、Synchronized 无法尝试获取锁，Lock 可以尝试获取锁，判断； 3、Synchronized 会自动释放锁（a线程执行完毕，b如果异常了，也会释放锁），lock锁是手动释放锁！如果你不释放就会死锁。 4、Synchronized （线程A（获得锁，如果阻塞），线程B（等待，一直等待）；）lock，可以尝试获取锁，失败了之后就放弃 5、Synchronized 一定是非公平的，但是 Lock 锁可以是公平的，通过参数设置； 6、代码量特别大的时候，我们一般使用Lock实现精准控制，Synchronized 适合代码量比较小的同步问题； 5 生产者消费者问题 面试手写题：单例模式、排序算法、死锁、生产者消费者 线程和线程之间本来是不能通信的，但是有时候我们需要线程之间可以协调操作： synchronized普通版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.zhangben.demo;/** * @description:目的： Synchronized 版 * 有两个线程：A B ，还有一个值初始为0，实现两个线程交替执行，对该变量 + 1，-1；交替10次 * 传统的 wait 和 notify方法不能实现精准唤醒通知！ */public class Demo03 { public static void main(String[] args) { Data data = new Data(); new Thread(()-&gt;{ for (int i = 1; i &lt;=10 ; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"A\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt;=10 ; i++) { try { data.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"C\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt;=10 ; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"B\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt;=10 ; i++) { try { data.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"D\").start(); }}// 资源类// 线程之间的通信： 判断 执行 通知class Data{ private int number = 0; // +1 public synchronized void increment() throws InterruptedException { while (number!=0){ // 判断是否需要等待，使用if会造成虚假唤醒问题，程序会产生不正常数据 this.wait(); } number++; // 执行 System.out.println(Thread.currentThread().getName()+\"\\t\"+number); // 通知 this.notifyAll(); //唤醒所有线程 } // -1 public synchronized void decrement() throws InterruptedException { while (number==0){ // 判断是否需要等待 this.wait(); } number--; // 执行 System.out.println(Thread.currentThread().getName()+\"\\t\"+number); // 通知 this.notifyAll(); //唤醒所有线程 }} 问题：四条线程可以实现交替吗？用if不能，会产生虚假唤醒问题！看代码 使用juc实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.zhangben.demo;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/**实现线程交替执行！主要的实现目标：精准的唤醒线程！三个线程：A B C三个方法：A p5 B p10 C p15 依次循环 */public class Demo04 { public static void main(String[] args) { Data2 data = new Data2(); new Thread(()-&gt;{ for (int i = 1; i &lt;= 10; i++) { data.print5(); } },\"A\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt;= 10; i++) { data.print10(); } },\"B\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt;= 10; i++) { data.print15(); } },\"C\").start(); }}// 资源类class Data2{ private int number = 1; // 1A 2B 3C private Lock lock = new ReentrantLock(); // 实现精准访问 private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void print5() { lock.lock(); try { // 判断 while (number!=1){ condition1.await(); } // 执行 for (int i = 1; i &lt;= 5; i++) { System.out.println(Thread.currentThread().getName() + \"\\t\" + i); } // 通知第二个线程干活！ number = 2; condition2.signal(); // 唤醒 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); // 一定要解锁 } } public void print10() { lock.lock(); try { // 判断 while (number!=2){ condition2.await(); } // 执行 for (int i = 1; i &lt;= 10; i++) { System.out.println(Thread.currentThread().getName() + \"\\t\" + i); } // 通知3干活 number = 3; condition3.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void print15() { lock.lock(); try { // 判断 while (number!=3){ condition3.await(); } // 执行 for (int i = 1; i &lt;= 15; i++) { System.out.println(Thread.currentThread().getName() + \"\\t\" + i); } // 通知 1 干活 number = 1; condition1.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }} 6 八锁现象线程彻底理解锁下面是八个demo 12345678910111213141516171819202122232425262728293031323334package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**1、标准的访问情况下，先执行 sendEmail 还是 sendSMS 答案：sendEmail 被 synchronized 修饰的方式，锁的对象是方法的调用者，所以说这里两个方法调用的对象是同一个 先调用的先执行！ */public class LockDemo01 { public static void main(String[] args) throws InterruptedException { Phone phone = new Phone(); new Thread(()-&gt;{ phone.sendEmail(); },\"A\").start(); TimeUnit.SECONDS.sleep(2); new Thread(()-&gt;{ phone.sendSMS(); },\"B\").start(); }}class Phone{ public synchronized void sendEmail(){ System.out.println(\"sendEmail\"); } public synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 123456789101112131415161718192021222324252627282930313233343536373839package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**2、sendEmail休眠3秒后 ，先执行 sendEmail 还是 sendSMS 答案：sendEmail 被 synchronized 修饰的方式，锁的对象是方法的调用者，所以说这里两个方法调用的对象是同一个 先调用的先执行！ */public class LockDemo02 { public static void main(String[] args) throws InterruptedException { Phone2 phone = new Phone2(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(2); new Thread(()-&gt;{ phone.sendSMS(); },\"B\").start(); }}class Phone2{ public synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 12345678910111213141516171819202122232425262728293031323334353637383940package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**3、增加一个普通方法，请问先打印那个 sendEmail 还是 hello 答案：hello 新增加的这个方法没有 synchronized 修饰，不是同步方法，不受锁的影响！ */public class LockDemo03 { public static void main(String[] args) throws InterruptedException { Phone3 phone = new Phone3(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone.hello(); },\"B\").start(); }}class Phone3{ public synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(4); System.out.println(\"sendEmail\"); } // 没有 synchronized 没有 static 就是普通方式 public void hello(){ System.out.println(\"hello\"); }} 123456789101112131415161718192021222324252627282930313233343536373839package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**4、两个手机，请问先执行sendEmail 还是 sendSMS 答案：sendSMS 被 synchronized 修饰的方式，锁的对象是调用者；我们这里有两个调用者，两个方法在这里是两个锁 */public class LockDemo04 { public static void main(String[] args) throws InterruptedException { Phone4 phone1 = new Phone4(); Phone4 phone2 = new Phone4(); new Thread(()-&gt;{ try { phone1.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone2.sendSMS(); },\"B\").start(); }}class Phone4{ public synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhangben.lock8;import java.util.concurrent.TimeUnit;//LockDemo05.Class 模板,只有一个 static//new LockDemo05()，可以创建多个对象/**5、两个静态同步方法，同一个手机请问先执行sendEmail 还是 sendSMS 答案：sendEmail 只要方法被 static 修饰，锁的对象就是 Class模板对象,这个则全局唯一！所以说这里是同一个锁 并不是因为synchronized */public class LockDemo05 { public static void main(String[] args) throws InterruptedException { Phone5 phone = new Phone5(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone.sendSMS(); },\"B\").start(); }}class Phone5{ public static synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public static synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 123456789101112131415161718192021222324252627282930313233343536373839404142package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**6、两个静态同步方法，两个手机，请问先执行sendEmail 还是 sendSMS 答案：sendEmail 只要方法被 static 修饰，锁的对象就是 Class模板对象,这个则全局唯一！所以说这里是同一个锁 并不是因为synchronized */public class LockDemo06 { public static void main(String[] args) throws InterruptedException { Phone6 phone = new Phone6(); Phone6 phone2 = new Phone6(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone2.sendSMS(); },\"B\").start(); }}class Phone6{ public static synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public static synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 123456789101112131415161718192021222324252627282930313233343536373839404142package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**7、一个普通同步方法，一个静态同步方法，只有一个手机，请问先执行sendEmail 还是 sendSMS 答案：sendSMS synchronized 锁的是这个调用的对象 static 锁的是这个类的Class模板 这里是两个锁！ */public class LockDemo07 { public static void main(String[] args) throws InterruptedException { Phone7 phone = new Phone7(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone.sendSMS(); },\"B\").start(); }}class Phone7{ public static synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhangben.lock8;import java.util.concurrent.TimeUnit;/**7、一个普通同步方法，一个静态同步方法，两个手机，请问先执行sendEmail 还是 sendSMS 答案：sendSMS synchronized 锁的是这个调用的对象 static 锁的是这个类的Class模板 这里是两个锁！ */public class LockDemo08 { public static void main(String[] args) throws InterruptedException { Phone8 phone = new Phone8(); Phone8 phone2 = new Phone8(); new Thread(()-&gt;{ try { phone.sendEmail(); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ phone2.sendSMS(); },\"B\").start(); }}class Phone8{ public static synchronized void sendEmail() throws InterruptedException { TimeUnit.SECONDS.sleep(3); System.out.println(\"sendEmail\"); } public synchronized void sendSMS(){ System.out.println(\"sendSMS\"); }} 小结 1、new this 调用的这个对象，是一个具体的对象！ 2、static class 唯一的一个模板！ 在我们编写多线程程序得时候，只需要搞明白这个到底锁的是什么就不会出错了！ 1234567&gt; synchronized(Demo.class){&gt; &gt; }&gt; synchronized(this){&gt; &gt; }&gt; 7 不安全的集合类只要是并发环境，你的集合类都不安全（List、Map、Set）,juc建议使用线程安全的类 list不安全 1234567891011121314151617181920212223242526272829303132333435package com.zhangben.unsafe;import java.util.List;import java.util.UUID;import java.util.concurrent.CopyOnWriteArrayList;/** * 30条执行arraylist的add方法会报错，这里arraylist的add方法是线程不安全的 * 故障现象：ConcurrentModificationException 并发修改异常 * 导致原因：add方法没有锁！ * 解决方案： * 1、List&lt;String&gt; list = new Vector&lt;&gt;(); //jdk1.0 就存在的！效率低 * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());//工具类转换成安全的 * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();//使用线程安全的类 * * 什么是 CopyOnWrite； 写入是复制 （思想 COW） * 多个调用者同时要相同的资源；这个有一个指针的概念。 * 读写分离的思想： */public class UnSafeList { public static void main(String[] args) {// List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");// list.forEach(System.out::println);// List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;= 30; i++) { new Thread(()-&gt;{ list.add(UUID.randomUUID().toString().substring(0,3)); System.out.println(list); },String.valueOf(i)).start(); } }} COW 的思想：（不要害怕看源码，因为到了最底层都是你能够看懂的代码）,CopyOnWriteArrayList的add是加锁的。 1234567891011121314public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); }} set不安全 12345678910111213141516171819202122232425package com.zhangben.unsafe;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;// ConcurrentModificationExceptionpublic class UnSafeSet { public static void main(String[] args) { // HashSet 底层是什么 就是 HashMap // add，就是 HashMap 的 key；// Set&lt;String&gt; set = new HashSet&lt;&gt;();// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet(); for (int i = 1; i &lt;=30 ; i++) { new Thread(()-&gt;{ set.add(UUID.randomUUID().toString().substring(0,3)); System.out.println(set); },String.valueOf(i)).start(); } }} map不安全 12345678910111213141516171819202122232425package com.zhangben.unsafe;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;//ConcurrentModificationExceptionpublic class UnsafeMap { public static void main(String[] args) { // new HashMap&lt;&gt;() 工作中是这样用的吗？ 不是 // 加载因子0.75f;，容量 16； 这两个值工作中不一定这样用！ // 优化性能！hashmap初始容量16有时不够用，需要扩容会导致效率问题 // HashMap 底层数据结构，链表 + 红黑树 // = = = = = = =// Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); // 人生如程序，不是选择就是循环，时常的自我总结十分重要！ for (int i = 1; i &lt;=30 ; i++) { new Thread(()-&gt;{ map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,3)); System.out.println(map); },String.valueOf(i)).start(); } }}","link":"/2020/03/03/juc并发编程01/"},{"title":"juc并发编程02","text":"8 读写锁（了解） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.zhangben.rwlock;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/**独占锁（写锁）：一次只能被一个线程占有共享锁（读锁）：该锁可以被多个线程占有！ */public class ReadWriteLockDemo { public static void main(String[] args) { MyCacheLock myCache = new MyCacheLock(); // 模拟线程 // 写 for (int i = 1; i &lt;= 5; i++) { final int tempInt = i; new Thread(()-&gt;{ myCache.put(tempInt+\"\",tempInt+\"\"); },String.valueOf(i)).start(); } // 读 for (int i = 1; i &lt;= 5; i++) { final int tempInt = i; new Thread(()-&gt;{ myCache.get(tempInt+\"\"); },String.valueOf(i)).start(); } }}// 读、写class MyCache{ private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 读 ： 可以被多个线程同时读 public void get(String key){ System.out.println(Thread.currentThread().getName()+\"读取\" + key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+\"读取结果:\"+o); } // 写 ：应该是保证原子性 , 不应该被打扰 public void put(String key,Object value){ System.out.println(Thread.currentThread().getName()+\"写入\" + key); map.put(key,value); System.out.println(Thread.currentThread().getName()+\"写入ok\" ); }}// 加锁操作： 读写锁class MyCacheLock{ private volatile Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 读写锁 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 读 ： 可以被多个线程同时读 public void get(String key){ // 这些锁一定要匹配，否则就可能导致死锁！ readWriteLock.readLock().lock(); // 多个线程同时持有 try { System.out.println(Thread.currentThread().getName()+\"读取\" + key); Object o = map.get(key); System.out.println(Thread.currentThread().getName()+\"读取结果:\"+o); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.readLock().unlock(); } } // 写 ：应该是保证原子性 , 不应该被打扰 public void put(String key,Object value){ readWriteLock.writeLock().lock(); // 只能被一个线程占用 try { System.out.println(Thread.currentThread().getName()+\"写入\" + key); map.put(key,value); System.out.println(Thread.currentThread().getName()+\"写入ok\" ); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.writeLock().unlock(); } }} 9 阻塞队列 队列 ： FIFO ，先进先出 栈：Stack，后进先出 阻塞：什么情况下肯定会阻塞！ 我为什么要使用阻塞队列： 很多人写多线程程序的时候，线程之间的通信，他不关心唤醒！阻塞队列！ 之前可以通过wait/notify，condition等方式，现在也可以用阻塞队列尝试 阻塞队列是一个新东西吗？ List、Set 这些我们都学过，其实 BlockingQueue 和 这些是一样的； 四组API 方法 第一组会抛出异常 返回一个布尔值，不会抛出异常 延时等待 一直等待 插入 add() offer（e） offer（e，time） put（） 取出 remove() poll（） poll（time） take（） 检查 element（） peek（） - - 队列一般可以检测第一个元素是谁！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.zhangben.queue;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;/** * * 功能描述: 四种策略：1、 报错、2、抛弃不报错、3、超时等待4、一直等待 * 1、blockingQueue.add，blockingQueue.element(),blockingQueue.remove() * 报错：java.lang.IllegalStateException: Queue full * 2、blockingQueue.offer,blockingQueue.peek()，blockingQueue.poll() * 抛弃不报错 * 3、offer（e，time），poll（time） * 尝试等待，超时会返回false，不报错 * 4、blockingQueue.put，blockingQueue.take() * 一直等待 * * */public class BlockingDemo { public static void main(String[] args) throws InterruptedException { // 参数，队列的大小 ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);// blockingQueue.add(\"a\");// blockingQueue.add(\"b\");// blockingQueue.add(\"c\");// //blockingQueue.add(\"d\");// System.out.println(blockingQueue.element());// System.out.println(\"========================\");// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.remove());// System.out.println(blockingQueue.offer(\"a\"));// System.out.println(blockingQueue.offer(\"b\"));// System.out.println(blockingQueue.offer(\"c\"));// System.out.println(blockingQueue.peek());// System.out.println(\"========\");// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.offer(\"a\"));// System.out.println(blockingQueue.offer(\"b\"));// System.out.println(blockingQueue.offer(\"c\"));// System.out.println(blockingQueue.offer(\"d\",3L, TimeUnit.SECONDS)); // 尝试等待3秒，就会失败！返回false// System.out.println(\"========\");// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll());// System.out.println(blockingQueue.poll()); blockingQueue.put(\"a\"); blockingQueue.put(\"b\"); blockingQueue.put(\"c\"); System.out.println(\"准备放入第四个元素\");// blockingQueue.put(\"d\"); // 队列满了，一直等，并且会阻塞！ System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take()); System.out.println(blockingQueue.take());// System.out.println(blockingQueue.take()); // 队列空了，一直等，并且会阻塞！ }} 同步队列：SynchronousQueue ， 只有一个容量！ 每一个put操作，就需要有一个 take操作！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhangben.queue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;// 同步队列 : 只能存放一个值！public class SynchronousQueueDemo { public static void main(String[] args) { // 特殊的阻塞队列 BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); // A 存 new Thread(()-&gt;{ try { System.out.println(Thread.currentThread().getName() + \"put a\"); blockingQueue.put(\"a\"); System.out.println(Thread.currentThread().getName() + \"put b\"); blockingQueue.put(\"b\"); System.out.println(Thread.currentThread().getName() + \"put c\"); blockingQueue.put(\"c\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"A\").start(); // B 取 new Thread(()-&gt;{ try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() +\"take \\t\"+ blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() +\"take \\t\"+ blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() +\"take \\t\"+ blockingQueue.take()); } catch (InterruptedException e) { e.printStackTrace(); } },\"B\").start(); }} 同步队列实现生产者消费者问题，待实现。。。 10 线程池 池化技术 程序运行的本质：占用系统资源！ ==提高程序的使用率，降低我们一个性能消耗== 线程池、连接池、内存池、对象池 ………… 为什么要用线程池：实现线程复用 关于我们的线程池 三大方法、七大参数、4种拒绝策略 阿里巴巴开发手册规定 123456789101112131415161718192021222324252627282930package com.zhangben.pool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo01 { public static void main(String[] args) { // 单例，只能有一个线程！// ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 固定的线程数// ExecutorService threadPool = Executors.newFixedThreadPool(8); // 遇强则强！可伸缩！// ExecutorService threadPool = Executors.newCachedThreadPool(); try { // 线程池的使用方式！ for (int i = 0; i &lt; 30; i++) { threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName() + \" ok\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 使用完毕后需要关闭！ threadPool.shutdown(); } }} 可以点进去看下源码，这三种不建议使用Executors.newSingleThreadExecutor();Executors.newFixedThreadPool(1);Executors.newCachedThreadPool();发现七大参数 1234567891011121314151617181920212223242526272829303132333435new ThreadPoolExecutor(0, Integer.MAX_VALUE, // 约等于21亿 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())//再点进去看这个方法public ThreadPoolExecutor(int corePoolSize, // 核心池线程数大小 (常用) int maximumPoolSize, // 最大的线程数大小 (常用) long keepAliveTime, // 超时等待时间 (常用) TimeUnit unit, // 时间单位 (常用) BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列(常用) ThreadFactory threadFactory, // 线程工厂 RejectedExecutionHandler handler // 拒绝策略(常用)) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;} 再看下线程池的策略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhangben.pool;import java.util.concurrent.*;public class ThreadPoolDemo01 { public static void main(String[] args) { // 单例，只能有一个线程！// ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 固定的线程数// ExecutorService threadPool = Executors.newFixedThreadPool(1); //遇强则强！可伸缩！// ExecutorService threadPool = Executors.newCachedThreadPool(); // 程序员必须要从程序去获取变量 System.out.println(Runtime.getRuntime().availableProcessors()); ExecutorService threadPool = new ThreadPoolExecutor( 2, Runtime.getRuntime().availableProcessors(), 3L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); /** * 1、ThreadPoolExecutor.AbortPolicy()； 抛出异常，丢弃任务 * 思路：看到效果一样的东西，可以研究研究！ * 2、ThreadPoolExecutor.DiscardPolicy()；不抛出异常，丢弃任务 * 3、ThreadPoolExecutor.DiscardOldestPolicy()； 尝试获取任务，不一定执行！ * 4、ThreadPoolExecutor.CallerRunsPolicy()； 哪来的去哪里找对应的线程执行！ */ try { // 线程池的使用方式！ for (int i = 0; i &lt; 9; i++) { threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName() + \" ok\"); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 使用完毕后需要关闭！ threadPool.shutdown(); } }} 四大拒绝策略 （） 请你谈谈 最大线程池 该如何设置啊？ CPU密集型： 根据CPU的处理器数量来定！保证最大效率 IO密集型： 50 个线程都是进程操作大io资源, 比较耗时！ &gt; 这个常用的 IO 任务数！ 11 函数式接口在java.util.function包下，一般看四个就可以了，其他都是复用或者实现 所有的函数式接口都可以用来简化编程模型： 都可以使用lambda表达式简化！ Function ： 有一个输入参数有一个输出参数 Consumer：有一个输入参数，没有输出参数 Supplier：没有输入参数，只有输出参数 Predicate：有一个输入参数，判断是否正确！ 1234567891011121314151617181920212223242526272829package com.zhangben.function;import java.util.function.Function;/** * 函数式接口是我们现在必须要要掌握且精通的 * 4个！ * Java 8 * * Function ： 有一个输入参数有一个输出参数 * Consumer：有一个输入参数，没有输出参数 * Supplier：没有输入参数，只有输出参数 * Predicate：有一个输入参数，判断是否正确！ */public class Demo01 { public static void main(String[] args) { //// Function&lt;String,Integer&gt; function = new Function&lt;String,Integer&gt;() {// @Override// public Integer apply(String str) {// return str.length();// }// }; // (参数)-&gt;{方法体} Function&lt;String,Integer&gt; function = (str)-&gt;{return str.length();}; System.out.println(function.apply(\"a45645646\")); }} 12345678910111213141516171819202122package com.zhangben.function;import java.util.function.Predicate;// Predicatepublic class Demo02 { public static void main(String[] args) {// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {// @Override// public boolean test(String str) {// return str.isEmpty();// }// }; Predicate&lt;String&gt; predicate = str-&gt;{return str.isEmpty();}; System.out.println(predicate.test(\"456\")); }} 123456789101112131415161718192021222324252627282930package com.zhangben.function;import java.util.function.Consumer;import java.util.function.Supplier;public class Demo03 { public static void main(String[] args) {// Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {// // 语法糖// @Override// public String get() {// return \"《hello，spring》\";// }// }; Supplier&lt;String&gt; supplier = ()-&gt;{return \"《hello，spring》\";}; Consumer&lt;String&gt; consumer = s-&gt;{ System.out.println(s);};// Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {// @Override// public void accept(String s) {// System.out.println(s);// }// }; consumer.accept(supplier.get()); }} 12 Stream流式计算java.util.stream 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhangben.stream;import java.util.Arrays;import java.util.List;// 数据库、集合 ： 存数据的// Stream：计算和处理数据交给 Streampublic class StreamDemo { /** * 按条件用户筛选： * 1、id 为偶数 * 2、年龄大于24 * 3、用户名大写 映射 * 4、用户名倒排序 * 5、输出一个用户 * * 请你只用一行代码完成！ */ public static void main(String[] args) { User u1 = new User(1,\"a\",23); User u2 = new User(2,\"b\",24); User u3 = new User(3,\"c\",22); User u4 = new User(4,\"d\",28); User u5 = new User(6,\"e\",26); // 存储 List&lt;User&gt; users = Arrays.asList(u1, u2, u3, u4, u5); // 计算等操作交给流 // forEach(消费者类型接口) users.stream() .filter(u-&gt;{return u.getId()%2==0;}) .filter(u-&gt;{return u.getAge()&gt;24;}) .map(u-&gt;{return u.getName().toUpperCase();}) .sorted((o1,o2)-&gt;{return o2.compareTo(o1);}) .limit(1) .forEach(System.out::println); // 在JDK1.5 的时候，枚举：反射、注解、泛型 // 在JDK1.8 的时候 函数式接口、Stream流式计算、lambda表达式、链式编程！ // 无论何时，都还需要掌握一个东西叫 JVM； // JVM: 你会了这个技术不会觉得你恨厉害！ }} 13 分支合并 什么是 forkjoin MapReduce：input-&gt;split-&gt;map-&gt;reduce-&gt;output 主要就是两步： 1、任务拆分 2、结果合并 前提：forkjoin 一定是用在大数据量的情况下 工作原理：工作窃取 底层维护的是一个双端队列； 好处：效率高 坏处：产生资源争夺 测试一下Forkjoin 1234567891011121314151617181920212223242526272829303132333435363738package com.zhangben.forkjoin;import java.util.concurrent.RecursiveTask;// 求和public class ForkJoinWork extends RecursiveTask&lt;Long&gt; { private Long start; private Long end; private static final Long tempLong = 10000L; // 临界值：只要超过了这个值 ForkJoin效率就会更好！ public ForkJoinWork(Long start, Long end) { this.start = start; this.end = end; } // 计算方法 @Override protected Long compute() { // 临界值判断 if ((end-start)&lt;=tempLong){ Long sum = 0L; for (Long i = start; i &lt;= end ; i++) { sum += i; } return sum; }else { // 第二种方式 long middle = (end + start) / 2; ForkJoinWork right = new ForkJoinWork(start,middle); right.fork(); // 压入线程队列 ForkJoinWork left = new ForkJoinWork(middle+1,end); left.fork(); // 压入线程队列 // 获得结果 join 会阻塞等待结果 return right.join() + left.join(); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zhangben.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;// 技术没有高低之分，只有使用技术的人有高低之别// 因为场景适合，所以使用！public class MyTest { public static void main(String[] args) throws ExecutionException, InterruptedException { test1(); // times:154 r=&gt;500000000500000000 test2(); // times:10235 r=&gt;500000000500000000 test3(); // times:15189 r=&gt;500000000500000000 } // 普通的 3000 private static void test3() { Long sum = 0L; long start = System.currentTimeMillis(); for (Long i = 0L; i &lt;= 2L ; i++) { sum += i; } long end = System.currentTimeMillis(); System.out.println(\"times:\"+(end-start)+\" r=&gt;\"+sum); } // forkjoin 6000 private static void test2() throws ExecutionException, InterruptedException { long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinWork forkJoinWork = new ForkJoinWork(0L, 2L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(forkJoinWork); Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(\"times:\"+(end-start)+\" r=&gt;\"+sum); } // 并行流计算 9000 流计算 private static void test1() { long start = System.currentTimeMillis(); // 流计算 long sum = LongStream.rangeClosed(0L, 2L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(\"times:\"+(end-start)+\" r=&gt;\"+sum); }} 14 异步回调Future CompletableFuture 代码测试 12345678910111213141516171819202122232425262728293031323334353637package com.zhangben.future;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;public class CompletableFutureDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { // 没有返回值,好比多线程，功能更强大！// CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {// try {// TimeUnit.SECONDS.sleep(2);// } catch (InterruptedException e) {// e.printStackTrace();// }// System.out.println(Thread.currentThread().getName() + \"没有返回值！\");// });// System.out.println(\"111111\");// completableFuture.get(); // 有返回值 // 任务 CompletableFuture&lt;Integer&gt; uCompletableFuture = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName()+\"=&gt;supplyAsync!\"); int i = 10/0; return 1024; }); System.out.println(uCompletableFuture.whenComplete((t, u) -&gt; { // 成功 System.out.println(\"t=&gt;\" + t); // 正确结果 System.out.println(\"u=&gt;\" + u); // 错误信息 }).exceptionally(e -&gt; { // 失败，如果错误就返回错误的结果！ System.out.println(\"e:\" + e.getMessage()); return 500; }).get()); }}","link":"/2020/03/08/juc并发编程02/"},{"title":"java配置springmvc","text":"使用java配置方式搭建springmvc本文借鉴：http://springboot.javaboy.org/2019/0528/javassm 我只说下在写代码的过程中遇到的问题： @Controller和@RestController的问题 在写返回视图解析的时候用@Controller注解； 返回格式问题，@GetMapping中的两个属性consumes和produces，前者是入参格式和编码设置，后者是返回设置 1@GetMapping(value = &quot;/hello&quot;,produces = &quot;text/html;charset=UTF-8&quot;) idea配置tomcat启动项目，报错内存不足； idea的快捷键使用： sout，psvm，fori，var，自己设置templates","link":"/2020/02/29/java配置springmvc/"},{"title":"juc并发编程03","text":"","link":"/2020/03/08/juc并发编程03/"},{"title":"'我的第一篇文章啊'","text":"居然用的是md，看来要写文章还要熟悉这个语法啊！今天就学了搭建这个网站，白天看了一些lambda的文章，看到大神们的博客和公众号都很厉害的，好好学习吧","link":"/2018/07/10/我的第一篇文章啊/"},{"title":"使用hexo+icarus搭建个人博客","text":"1 下载icarus主题 进入本地博客主目录，点击鼠标右键Git Bash Here,进入命令行界面，输入 1git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 打开themes文件夹，就会发现多了一个icarus文件夹，这就是主题的所有文件 2 配置主题2.1 更改博客主题，启用icarus 进入blog的配置文件_config.yml,找到theme，将主题改为icarus 1theme: icarus 本地启动blog服务 123hexo cleanhexo ghexo s 浏览器输入 http://localhost:4000/，即可看到icarus主题效果 2.2 博客个性化配置我只说下我改动的文件下吧，以后也能找到改动点： \\blog\\themes\\icarus\\layout\\widget\\profile.ejs 头像上的滚动字体 \\blog\\themes\\icarus\\layout\\tags.ejs 右侧时光荏苒字体和人体时钟 \\blog\\themes\\icarus\\source\\dist\\music.js 1之前想用APlayer做音乐的，但网易音乐链接太难弄了，这个就放弃了，页面上的是网易里能生成连接的直接生成的iframe代码，和这个js无关,能得到链接的话用这个还是很舒服的 \\blog\\themes\\icarus\\layout\\common\\navbar.ejs iframe标签音乐代码的位置，我放在这里了 \\blog\\source\\404.html 错误页面跳转腾讯公益页面，_config.xml里要配置 \\blog\\themes\\icarus\\source\\css\\style.styl 配置雪花飘落效果，把body的background-color属性注释掉 \\blog\\themes\\icarus\\source\\js\\src 这个是新建的src文件夹，放自己的js click_show_text.js (“❤他们❤”, “❤都说❤”, “❤我是❤”, “❤一个❤”, “❤大帅哥❤”)点击鼠标的实现 FunnyTitle.js 浏览器搞笑标题，切到其他页面时，浏览器的ico和字会变化 snow.js 背景雪花飘落的实现 \\blog\\themes\\icarus\\layout\\common\\footer.ejs 网站运行天数 \\blog\\themes\\icarus\\layout\\layout.ejs 把自己的js加进来 1234567891011121314&lt;!-- 雪花特效 --&gt; &lt;script type=\"text/javascript\"&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) { document.write('&lt;script type=\"text/javascript\" src=\"/js/src/snow.js\"&gt;&lt;\\/script&gt;'); } &lt;/script&gt; &lt;!--单击显示文字--&gt; &lt;script type=\"text/javascript\" src=\"/js/src/click_show_text.js\"&gt;&lt;/script&gt; &lt;!--浏览器搞笑标题--&gt; &lt;script type=\"text/javascript\" src=\"/js/src/FunnyTitle.js\"&gt;&lt;/script&gt; &lt;!--动态线条背景--&gt; &lt;script type=\"text/javascript\" color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt; &lt;/script&gt; \\blog\\themes\\icarus_config.yml 主要配置都是这里实现的，官网上的就很不错https://github.com/ppoffice/hexo-theme-icarus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250# Version of the Icarus theme that is currently usedversion: 2.6.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicon.ico# Additional HTML meta tags in an array.meta: # canonical_url of your sitecanonical_url: www.52wufang.com# Path or URL to RSS atom.xmlrss: # 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/IMG_1021.JPG# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: Download on GitHub: icon: fab fa-github url: &apos;https://github.com/LightingStar/LightingStar.github.io&apos;# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: &apos;https://creativecommons.org/&apos; Attribution 4.0 International: icon: fab fa-creative-commons-by url: &apos;https://creativecommons.org/licenses/by/4.0/&apos; Download on GitHub: icon: fab fa-github url: &apos;https://github.com/ppoffice/hexo-theme-icarus&apos;# 文章显示设置article: # Code highlight settings highlight: # 代码主题atom-one-light亮色，atom-one-dark暗色 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-dark # Show code copying button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Searchsearch: # Name of the search plugin type: insight# 评论插件设置,我是用的valine，去注册然后下面直接配置就好# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Commentcomment: # Name of the comment plugin type: valine app_id: 自己的appid app_key: 自己的appkey verify: false notify: false placeholder: ヾﾉ≧∀≦)o来啊，快活啊! # Donation entries# 打赏功能# https://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: &apos;/images/zhifubao.jpg&apos; - # 微信 type: wechat # 二维码图片 qrcode: &apos;/images/weixin.jpg&apos; - # Donation entry name # type: paypal # Paypal business ID or email address # business: &apos;&apos; # Currency code # currency_code: USD - # Donation entry name # type: patreon # URL to the Patreon page # url: &apos;&apos;# Share plugin settings# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Shareshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: AwesomeZhang # 作者身份描述（字符串） author_title: 程序员的自我修养 # 作者当前居住地 location: China,Shanghai # 头像（可用本地图片或网络图片链接） avatar: &apos;/images/IMG_3218.JPG&apos; # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: false # Path or URL for the follow button # follow_link: &apos;https://github.com/LightingStar&apos; # 个人介绍部件底部图标社交链接 # social_links: # Github: # icon: fab fa-github # url: &apos;https://github.com/LightingStar&apos; # Facebook: # icon: fab fa-facebook # url: &apos;https://facebook.com&apos; # Twitter: # icon: fab fa-twitter # url: &apos;https://twitter.com&apos; # Dribbble: # icon: fab fa-dribbble # url: &apos;https://dribbble.com&apos; # RSS: # icon: fas fa-rss # url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # Widget name type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: 个人网站: &apos;https://www.52wufang.com&apos; 博客园: &apos;https://www.cnblogs.com/tcmlflw/&apos; Github: &apos;https://github.com/LightingStar&apos; CSDN: &apos;https://blog.csdn.net/weixin_38120514&apos; - # Widget name type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: left - # 标签 type: tag # Where should the widget be placed, left or right position: right# Other plugin settingsplugins: # Enable page animations animejs: true # Enable the lightGallery and Justified Gallery plugins # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/ gallery: true # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated-browser: true # Enable the MathJax plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/ mathjax: true # Show the back to top button on mobile devices back-to-top: true # Google Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics google-analytics: # Google Analytics tracking id tracking_id: # Baidu Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics baidu-analytics: # Baidu Analytics tracking id tracking_id: 我用的是这个，自己百度注册 # Hotjar user feedback plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar hotjar: # Hotjar site id site_id: # Show a loading progress bar at top of the page progressbar: true # BuSuanZi site/page view counter # https://busuanzi.ibruce.info 左下角统计访问量 busuanzi: true# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL of the webfont CDN provider fontcdn: google # Name or URL of the webfont Icon CDN provider iconcdn: fontawesome \\blog_config.yml 网站的主要显示信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 张奔的个人网站subtitle: 在魔都的点点滴滴description: 我能坚持日更一个月吗keywords: 人生，梦想，程序员author: 张奔language: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://www.52wufang.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :lang# source下的404公益页面不要渲染skip_render: - 404.html# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus# Deployment 使用hexo d命令直接传到github，使用github自带域名就能直接访问效果## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:LightingStar/LightingStar.github.io.git branch: master# 右下角看板娘控件live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-koharu display: position: right width: 150 height: 300 mobile: show: false react: opacity: 0.7 2.3 博客配置域名分两步，步骤没关系； 第一，域名申请，我的是阿里云上直接买的 解析域名，直接在阿里域名操作台操作,添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。 第二，本地博客所在目录下的 source 目录中（注意不要放错位置了），创建一个 CNAME 文件，编辑文件，内容就是你的域名,比如我的52wufang.com,然后执行 hexo d 命令将这个文件上传到 GitHub 就可以了。 这样github仓库地址和域名就绑定在一起了，可以直接访问观察效果了 2.4 写文章一般都是支持md语法的，使用好用的编辑器，注意语法就好，简单说下自己遇到的几个： 设置图片路径问题，配置文件中的 post_asset_folder 选项的值设置为 true，创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句添加图片 1![示例图片](title/example.PNG &quot;示例图片&quot;) 文章展示问题，在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容 如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简 这时，我们只需在文章中使用 标志即可，表示只会显示标志前面的内容 文章的模板设置和头部设置，类似这种的，官网上可查看更多的意思： 1234title: Titledate: YYYY-MM-DD HH:MM:SStags: [tag1, tag2, ...]categories: category 插入图片资源，本地图片统一放在source/images文件夹中，也可以使用网络图片链接 12![](/images/test.jpg)&lt;img src=&quot;/images/test.jpg&quot;&gt; 后续改了：双栏模式，文章区域放宽，参考issue或下面链接： https://github.com/ppoffice/hexo-theme-icarus/issues/434 https://dp2px.com/2019/06/04/icarus-theme/","link":"/2020/02/27/使用hexo-icarus搭建个人博客/"}],"tags":[{"name":"juc并发编程实践","slug":"juc并发编程实践","link":"/tags/juc并发编程实践/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"tag1","slug":"tag1","link":"/tags/tag1/"},{"name":"tag2","slug":"tag2","link":"/tags/tag2/"},{"name":"开场立的flag","slug":"开场立的flag","link":"/tags/开场立的flag/"},{"name":"个人博客搭建","slug":"个人博客搭建","link":"/tags/个人博客搭建/"}],"categories":[{"name":"编程学习","slug":"编程学习","link":"/categories/编程学习/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"其它","slug":"其它","link":"/categories/其它/"},{"name":"测试分类","slug":"测试分类","link":"/categories/测试分类/"},{"name":"个人博客搭建","slug":"个人博客搭建","link":"/categories/个人博客搭建/"}]}